         :
         :
         :
         :            Disassembly of section .text:
         :
         :            00000000004067e0 <std::optional<std::reference_wrapper<int const> > binary_search_opt2_branchless2<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)>:
         :            _Z30binary_search_opt2_branchless2ILb1EESt8optionalISt17reference_wrapperIKiEERKNSt11conditionalIXT_ESt6vectorIi16AlignedAllocatorIiEES6_IiSaIiEEE4typeEi():
         :            return *base;
         :            }
         :
         :            template <bool Aligned>
         :            __attribute__((noinline))
         :            OptRef<const int32_t> binary_search_opt2_branchless2(const VecType<Aligned> & elements, int32_t target) {
    0.53 :   4067e0: push   %rbp
    0.00 :   4067e1: mov    %esi,%r8d
    0.00 :   4067e4: mov    %rsp,%rbp
    0.00 :   4067e7: and    $0xffffffffffffffe0,%rsp
         :            data() _GLIBCXX_NOEXCEPT
         :            { return _M_data_ptr(this->_M_impl._M_start); }
         :
         :            const _Tp*
         :            data() const _GLIBCXX_NOEXCEPT
         :            { return _M_data_ptr(this->_M_impl._M_start); }
    0.00 :   4067eb: mov    (%rdi),%rsi
         :            { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
    0.00 :   4067ee: mov    0x8(%rdi),%rdx
    0.00 :   4067f2: sub    %rsi,%rdx
    0.23 :   4067f5: sar    $0x2,%rdx
         :            const int32_t * base = elements.data();
         :            int32_t len = elements.size();
         :            while (len > 1) {
    0.00 :   4067f9: cmp    $0x1,%edx
    0.00 :   4067fc: jle    406820 <std::optional<std::reference_wrapper<int const> > binary_search_opt2_branchless2<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x40>
    0.00 :   4067fe: mov    %edx,%eax
         :            int32_t half = len / 2;
    5.02 :   406800: mov    %eax,%edx
    0.02 :   406802: sar    %edx
         :            if (*(base + half - 1) < target) {
    4.84 :   406804: movslq %edx,%rcx
    2.57 :   406807: lea    0x0(,%rcx,4),%rdi
    2.91 :   40680f: cmp    %r8d,-0x4(%rsi,%rcx,4)
    0.00 :   406814: jge    406819 <std::optional<std::reference_wrapper<int const> > binary_search_opt2_branchless2<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x39>
         :            base += half;
   29.80 :   406816: add    %rdi,%rsi
         :            }
         :            len -= half;
   38.81 :   406819: sub    %edx,%eax
         :            while (len > 1) {
    8.03 :   40681b: cmp    $0x1,%eax
    0.00 :   40681e: jg     406800 <std::optional<std::reference_wrapper<int const> > binary_search_opt2_branchless2<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x20>
         :            }
         :            if (*base != target) {
         :            return std::nullopt;
    0.92 :   406820: xor    %eax,%eax
         :            if (*base != target) {
    0.06 :   406822: cmp    %r8d,(%rsi)
    0.00 :   406825: jne    406831 <std::optional<std::reference_wrapper<int const> > binary_search_opt2_branchless2<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x51>
         :            }
         :            return *base;
    1.52 :   406827: mov    %rsi,-0x10(%rsp)
    0.00 :   40682c: mov    $0x1,%eax
    0.02 :   406831: mov    %al,-0x8(%rsp)
         :            }
    0.02 :   406835: mov    -0x10(%rsp),%rax
    1.70 :   40683a: mov    -0x8(%rsp),%rdx
    2.99 :   40683f: leaveq
    0.00 :   406840: retq
 Percent |	Source code & Disassembly of binary_search for cycles:u (4770 samples, percent: local period)
-------------------------------------------------------------------------------------------------------------
         :
         :
         :
         :            Disassembly of section .text:
         :
         :            0000000000406770 <std::optional<std::reference_wrapper<int const> > binary_search_opt1_branchless<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)>:
         :            _Z29binary_search_opt1_branchlessILb1EESt8optionalISt17reference_wrapperIKiEERKNSt11conditionalIXT_ESt6vectorIi16AlignedAllocatorIiEES6_IiSaIiEEE4typeEi():
         :            return *it;
         :            }
         :
         :            template <bool Aligned>
         :            __attribute__((noinline))
         :            OptRef<const int32_t> binary_search_opt1_branchless(const VecType<Aligned> & elements, int32_t target) {
    0.54 :   406770: push   %rbp
    0.00 :   406771: mov    %rdi,%rax
    0.00 :   406774: mov    %esi,%edi
    0.00 :   406776: mov    %rsp,%rbp
    0.00 :   406779: and    $0xffffffffffffffe0,%rsp
         :            data() _GLIBCXX_NOEXCEPT
         :            { return _M_data_ptr(this->_M_impl._M_start); }
         :
         :            const _Tp*
         :            data() const _GLIBCXX_NOEXCEPT
         :            { return _M_data_ptr(this->_M_impl._M_start); }
    0.00 :   40677d: mov    (%rax),%rsi
         :            { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
    0.00 :   406780: mov    0x8(%rax),%rax
    0.34 :   406784: sub    %rsi,%rax
    0.00 :   406787: sar    $0x2,%rax
    0.00 :   40678b: jmp    4067a7 <std::optional<std::reference_wrapper<int const> > binary_search_opt1_branchless<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x37>
    0.00 :   40678d: nopl   (%rax)
         :            const int32_t * base = elements.data();
         :            int32_t len = elements.size();
         :            while (len > 1) {
         :            int32_t half = len / 2;
   11.19 :   406790: mov    %eax,%edx
    0.04 :   406792: sar    %edx
         :            if (*(base + half - 1) < target) {
    4.72 :   406794: movslq %edx,%rcx
    2.54 :   406797: lea    0x0(,%rcx,4),%r8
    5.29 :   40679f: cmp    %edi,-0x4(%rsi,%rcx,4)
    0.00 :   4067a3: jl     4067d0 <std::optional<std::reference_wrapper<int const> > binary_search_opt1_branchless<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x60>
         :            int32_t half = len / 2;
   28.13 :   4067a5: mov    %edx,%eax
         :            while (len > 1) {
    4.15 :   4067a7: cmp    $0x1,%eax
    0.00 :   4067aa: jg     406790 <std::optional<std::reference_wrapper<int const> > binary_search_opt1_branchless<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x20>
         :            else {
         :            len = half;
         :            }
         :            }
         :            if (*base != target) {
         :            return std::nullopt;
    1.07 :   4067ac: xor    %eax,%eax
         :            if (*base != target) {
    0.06 :   4067ae: cmp    %edi,(%rsi)
    0.00 :   4067b0: jne    4067bc <std::optional<std::reference_wrapper<int const> > binary_search_opt1_branchless<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x4c>
         :            }
         :            return *base;
    1.87 :   4067b2: mov    %rsi,-0x10(%rsp)
    0.02 :   4067b7: mov    $0x1,%eax
    0.00 :   4067bc: mov    %al,-0x8(%rsp)
         :            }
    0.04 :   4067c0: mov    -0x10(%rsp),%rax
    1.32 :   4067c5: mov    -0x8(%rsp),%rdx
    3.54 :   4067ca: leaveq
    0.00 :   4067cb: retq
    0.00 :   4067cc: nopl   0x0(%rax)
         :            base += half;
   27.10 :   4067d0: add    %r8,%rsi
         :            len = len - half;
    7.95 :   4067d3: sub    %edx,%eax
    0.08 :   4067d5: jmp    4067a7 <std::optional<std::reference_wrapper<int const> > binary_search_opt1_branchless<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x37>
 Percent |	Source code & Disassembly of binary_search for cycles:u (4708 samples, percent: local period)
-------------------------------------------------------------------------------------------------------------
         :
         :
         :
         :            Disassembly of section .text:
         :
         :            0000000000406bb0 <std::optional<std::reference_wrapper<int const> > binary_search_std<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)>:
         :            _Z17binary_search_stdILb1EESt8optionalISt17reference_wrapperIKiEERKNSt11conditionalIXT_ESt6vectorIi16AlignedAllocatorIiEES6_IiSaIiEEE4typeEi():
         :            return std::nullopt;
         :            }
         :
         :            template <bool Aligned>
         :            __attribute__((noinline))
         :            OptRef<const int32_t> binary_search_std(const VecType<Aligned> & elements, int32_t target) {
    0.53 :   406bb0: push   %rbp
    0.00 :   406bb1: mov    %rdi,%rax
    0.00 :   406bb4: mov    %esi,%edi
    0.00 :   406bb6: mov    %rsp,%rbp
    0.00 :   406bb9: and    $0xffffffffffffffe0,%rsp
         :            _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT
         :            : _M_current(_Iterator()) { }
         :
         :            explicit _GLIBCXX20_CONSTEXPR
         :            __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
         :            : _M_current(__i) { }
    0.00 :   406bbd: mov    0x8(%rax),%r8
    0.00 :   406bc1: mov    (%rax),%rsi
         :            _GLIBCXX20_CONSTEXPR
         :            inline typename __normal_iterator<_Iterator, _Container>::difference_type
         :            operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
         :            const __normal_iterator<_Iterator, _Container>& __rhs)
         :            _GLIBCXX_NOEXCEPT
         :            { return __lhs.base() - __rhs.base(); }
    0.29 :   406bc4: mov    %r8,%rax
    0.00 :   406bc7: sub    %rsi,%rax
    0.00 :   406bca: sar    $0x2,%rax
    0.00 :   406bce: xchg   %ax,%ax
         :            typedef typename iterator_traits<_ForwardIterator>::difference_type
         :            _DistanceType;
         :
         :            _DistanceType __len = std::distance(__first, __last);
         :
         :            while (__len > 0)
    3.39 :   406bd0: test   %rax,%rax
    0.00 :   406bd3: jle    406bf3 <std::optional<std::reference_wrapper<int const> > binary_search_std<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x43>
         :            {
         :            _DistanceType __half = __len >> 1;
    8.47 :   406bd5: mov    %rax,%rdx
    0.42 :   406bd8: sar    %rdx
         :            { _M_current += __n; return *this; }
    2.35 :   406bdb: lea    (%rsi,%rdx,4),%rcx
         :            _ForwardIterator __middle = __first;
         :            std::advance(__middle, __half);
         :            if (__comp(__middle, __val))
    5.40 :   406bdf: cmp    %edi,(%rcx)
    0.00 :   406be1: jge    406c18 <std::optional<std::reference_wrapper<int const> > binary_search_std<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x68>
         :            {
         :            __first = __middle;
         :            ++__first;
         :            __len = __len - __half - 1;
   30.21 :   406be3: sub    %rdx,%rax
         :            ++_M_current;
    7.87 :   406be6: lea    0x4(%rcx),%rsi
    0.02 :   406bea: sub    $0x1,%rax
         :            while (__len > 0)
    3.12 :   406bee: test   %rax,%rax
    0.00 :   406bf1: jg     406bd5 <std::optional<std::reference_wrapper<int const> > binary_search_std<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x25>
         :            auto it = std::lower_bound(elements.begin(), elements.end(), target);
         :            if(it == elements.end()) {
         :            return std::nullopt;
    0.69 :   406bf3: xor    %eax,%eax
         :            if(it == elements.end()) {
    0.04 :   406bf5: cmp    %r8,%rsi
    0.00 :   406bf8: je     406c04 <std::optional<std::reference_wrapper<int const> > binary_search_std<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x54>
         :            }
         :            return *it;
    0.56 :   406bfa: mov    %rsi,-0x10(%rsp)
    0.71 :   406bff: mov    $0x1,%eax
    0.09 :   406c04: mov    %al,-0x8(%rsp)
         :            }
    0.20 :   406c08: mov    -0x10(%rsp),%rax
    1.33 :   406c0d: mov    -0x8(%rsp),%rdx
    3.57 :   406c12: leaveq
    0.00 :   406c13: retq
    0.00 :   406c14: nopl   0x0(%rax)
         :            _DistanceType __half = __len >> 1;
   29.64 :   406c18: mov    %rdx,%rax
    1.06 :   406c1b: jmp    406bd0 <std::optional<std::reference_wrapper<int const> > binary_search_std<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x20>
 Percent |	Source code & Disassembly of binary_search for cycles:u (3938 samples, percent: local period)
-------------------------------------------------------------------------------------------------------------
         :
         :
         :
         :            Disassembly of section .text:
         :
         :            0000000000406d30 <std::optional<std::reference_wrapper<int const> > binary_search_opt6_eytzinger_branchless<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)>:
         :            _Z39binary_search_opt6_eytzinger_branchlessILb1EESt8optionalISt17reference_wrapperIKiEERKNSt11conditionalIXT_ESt6vectorIi16AlignedAllocatorIiEES6_IiSaIiEEE4typeEi():
         :            /**
         :            * @param elements_eytzinger Assume this array is 1-indexed.
         :            */
         :            template <bool Aligned>
         :            __attribute__((noinline))
         :            OptRef<const int32_t> binary_search_opt6_eytzinger_branchless(const VecType<Aligned> & elements_eytzinger, int32_t target) {
    0.33 :   406d30: push   %rbp
    0.00 :   406d31: mov    %rdi,%rax
    0.00 :   406d34: mov    %esi,%edi
    0.00 :   406d36: mov    %rsp,%rbp
    0.00 :   406d39: and    $0xffffffffffffffe0,%rsp
         :
         :            // [23.2.4.2] capacity
         :            /**  Returns the number of elements in the %vector.  */
         :            size_type
         :            size() const _GLIBCXX_NOEXCEPT
         :            { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
    0.00 :   406d3d: mov    (%rax),%rsi
    0.00 :   406d40: mov    0x8(%rax),%rax
    0.25 :   406d44: sub    %rsi,%rax
    0.00 :   406d47: mov    %rax,%rcx
    0.00 :   406d4a: sar    $0x2,%rcx
         :            int32_t k = 1;
         :            while(k < elements_eytzinger.size()) {
    0.00 :   406d4e: cmp    $0x4,%rax
    0.00 :   406d52: jbe    406d8e <std::optional<std::reference_wrapper<int const> > binary_search_opt6_eytzinger_branchless<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x5e>
         :            int32_t k = 1;
    0.00 :   406d54: mov    $0x1,%eax
         :            while(k < elements_eytzinger.size()) {
    0.00 :   406d59: mov    $0x1,%edx
    0.00 :   406d5e: xchg   %ax,%ax
         :            // avoid branch. But also leads to a problem:
         :            // We don't know which k leads to the target value!
         :            k = 2 * k + (elements_eytzinger[k] < target);
    6.22 :   406d60: cmp    %edi,(%rsi,%rdx,4)
   60.91 :   406d63: setl   %dl
    4.98 :   406d66: movzbl %dl,%edx
    5.67 :   406d69: lea    (%rdx,%rax,2),%eax
         :            while(k < elements_eytzinger.size()) {
    5.31 :   406d6c: movslq %eax,%rdx
    4.47 :   406d6f: cmp    %rcx,%rdx
    0.00 :   406d72: jb     406d60 <std::optional<std::reference_wrapper<int const> > binary_search_opt6_eytzinger_branchless<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x30>
         :            // at this round "(elements_eytzinger[k] < target) == 0", we will go left
         :            // But at the following rounds we must go right since in the left sub-tree of the target node
         :            // there's nothing larger than the target.
         :            // So the pattern of the final steps is : one step left, multiple steps right.
         :            // Therefore we can count the trailing ones to get back the matched "k".
         :            k >>= __builtin_ffs(~k);
    1.07 :   406d74: mov    %eax,%ecx
    0.08 :   406d76: mov    $0xffffffff,%edx
    0.69 :   406d7b: not    %ecx
    0.03 :   406d7d: bsf    %ecx,%ecx
    0.84 :   406d80: cmove  %edx,%ecx
    0.30 :   406d83: add    $0x1,%ecx
    0.33 :   406d86: sar    %cl,%eax
         :            // for each iteration, the binary representation of k is appended with "bit 0" if we go left
         :            // and appended with "bit 1" if we go right.
         :            // And we need to get rid of the redundant bits since "k" matches the target.
         :            // Then we use __builtin_ffs to find the first 1 from the LSB in "~k".
         :            // And we right shift "k" by that value to retrieve the answer.
         :            if(elements_eytzinger[k] != target) {
    0.71 :   406d88: cltq
         :            */
         :            const_reference
         :            operator[](size_type __n) const _GLIBCXX_NOEXCEPT
         :            {
         :            __glibcxx_requires_subscript(__n);
         :            return *(this->_M_impl._M_start + __n);
    0.00 :   406d8a: lea    (%rsi,%rax,4),%rsi
         :            return std::nullopt;
    0.25 :   406d8e: xor    %eax,%eax
         :            if(elements_eytzinger[k] != target) {
    0.00 :   406d90: cmp    %edi,(%rsi)
    0.00 :   406d92: jne    406d9e <std::optional<std::reference_wrapper<int const> > binary_search_opt6_eytzinger_branchless<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x6e>
         :            }
         :            return elements_eytzinger[k];
    1.98 :   406d94: mov    %rsi,-0x10(%rsp)
    0.00 :   406d99: mov    $0x1,%eax
    0.00 :   406d9e: mov    %al,-0x8(%rsp)
         :            }
    0.00 :   406da2: mov    -0x10(%rsp),%rax
    0.28 :   406da7: mov    -0x8(%rsp),%rdx
    5.30 :   406dac: leaveq
    0.00 :   406dad: retq
 Percent |	Source code & Disassembly of binary_search for cycles:u (3629 samples, percent: local period)
-------------------------------------------------------------------------------------------------------------
         :
         :
         :
         :            Disassembly of section .text:
         :
         :            0000000000406e40 <std::optional<std::reference_wrapper<int const> > binary_search_opt9_branch_removal<8, true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)>:
         :            _Z33binary_search_opt9_branch_removalILi8ELb1EESt8optionalISt17reference_wrapperIKiEERKNSt11conditionalIXT0_ESt6vectorIi16AlignedAllocatorIiEES6_IiSaIiEEE4typeEi():
         :            /**
         :            * @param elements_eytzinger Assume this array is 1-indexed.
         :            */
         :            template <int32_t PrefetchStrideInElements, bool Aligned>
         :            __attribute__((noinline))
         :            OptRef<const int32_t> binary_search_opt9_branch_removal(const VecType<Aligned> & elements_eytzinger, int32_t target) {
    0.58 :   406e40: push   %rbp
    0.00 :   406e41: mov    %rdi,%rax
    0.00 :   406e44: mov    %esi,%edi
         :            __lg(long __n)
         :            { return (int)sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
         :
         :            inline _GLIBCXX_CONSTEXPR unsigned long
         :            __lg(unsigned long __n)
         :            { return (int)sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
    0.00 :   406e46: mov    $0x3f,%r8d
    0.00 :   406e4c: mov    %rsp,%rbp
    0.00 :   406e4f: and    $0xffffffffffffffe0,%rsp
         :
         :            // [23.2.4.2] capacity
         :            /**  Returns the number of elements in the %vector.  */
         :            size_type
         :            size() const _GLIBCXX_NOEXCEPT
         :            { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
    0.00 :   406e53: mov    (%rax),%rsi
    0.28 :   406e56: mov    0x8(%rax),%r9
    0.00 :   406e5a: sub    %rsi,%r9
    0.00 :   406e5d: sar    $0x2,%r9
    0.00 :   406e61: bsr    %r9,%rax
    0.00 :   406e65: xor    $0x3f,%rax
    0.00 :   406e69: sub    %eax,%r8d
         :            int32_t iters = std::__lg(elements_eytzinger.size());
         :            int32_t k = 1;
         :            for(int32_t i = 0; i < iters; i++) {
    0.00 :   406e6c: test   %r8d,%r8d
    0.00 :   406e6f: jle    406f00 <std::optional<std::reference_wrapper<int const> > binary_search_opt9_branch_removal<8, true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0xc0>
    0.00 :   406e75: xor    %ecx,%ecx
         :            int32_t k = 1;
    0.39 :   406e77: mov    $0x1,%edx
    0.00 :   406e7c: nopl   0x0(%rax)
         :            __builtin_prefetch(elements_eytzinger.data() + k * PrefetchStrideInElements * sizeof(int32_t));
    2.09 :   406e80: lea    0x0(,%rdx,8),%eax
    3.00 :   406e87: cltq
    4.85 :   406e89: shl    $0x4,%rax
    3.67 :   406e8d: prefetcht0 (%rsi,%rax,1)
         :            k = 2 * k + (elements_eytzinger[k] < target);
   55.77 :   406e91: movslq %edx,%rax
    0.00 :   406e94: cmp    %edi,(%rsi,%rax,4)
    8.87 :   406e97: setl   %al
         :            for(int32_t i = 0; i < iters; i++) {
    3.80 :   406e9a: add    $0x1,%ecx
         :            k = 2 * k + (elements_eytzinger[k] < target);
    0.00 :   406e9d: movzbl %al,%eax
    3.39 :   406ea0: lea    (%rax,%rdx,2),%edx
         :            for(int32_t i = 0; i < iters; i++) {
    2.78 :   406ea3: cmp    %r8d,%ecx
    0.00 :   406ea6: jne    406e80 <std::optional<std::reference_wrapper<int const> > binary_search_opt9_branch_removal<8, true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x40>
         :            }
         :            // We remove the last round in the loop
         :            // and use a "cmove" like operation
         :            // because the last round is more possible to lead to branch miss
         :            int32_t val = (k < elements_eytzinger.size() ? elements_eytzinger[k] : 0);
    0.41 :   406ea8: movslq %edx,%rcx
         :            k = 2 * k + (val < target);
    0.00 :   406eab: add    %edx,%edx
         :            int32_t val = (k < elements_eytzinger.size() ? elements_eytzinger[k] : 0);
    0.00 :   406ead: xor    %eax,%eax
    0.00 :   406eaf: cmp    %rcx,%r9
    0.00 :   406eb2: jbe    406eb7 <std::optional<std::reference_wrapper<int const> > binary_search_opt9_branch_removal<8, true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x77>
    0.08 :   406eb4: mov    (%rsi,%rcx,4),%eax
         :            k = 2 * k + (val < target);
    0.36 :   406eb7: cmp    %edi,%eax
    0.19 :   406eb9: setl   %al
    0.06 :   406ebc: movzbl %al,%eax
    0.14 :   406ebf: add    %eax,%edx
         :
         :            k >>= __builtin_ffs(~k);
    0.06 :   406ec1: mov    $0xffffffff,%eax
    0.00 :   406ec6: mov    %edx,%ecx
    0.00 :   406ec8: not    %ecx
    0.14 :   406eca: bsf    %ecx,%ecx
    0.33 :   406ecd: cmove  %eax,%ecx
         :            if(elements_eytzinger[k] != target) {
         :            return std::nullopt;
    0.17 :   406ed0: xor    %eax,%eax
         :            k >>= __builtin_ffs(~k);
    0.00 :   406ed2: add    $0x1,%ecx
    0.30 :   406ed5: sar    %cl,%edx
         :            if(elements_eytzinger[k] != target) {
    0.61 :   406ed7: movslq %edx,%rdx
         :            */
         :            const_reference
         :            operator[](size_type __n) const _GLIBCXX_NOEXCEPT
         :            {
         :            __glibcxx_requires_subscript(__n);
         :            return *(this->_M_impl._M_start + __n);
    0.06 :   406eda: lea    (%rsi,%rdx,4),%rdx
    0.11 :   406ede: cmp    %edi,(%rdx)
    0.00 :   406ee0: jne    406eec <std::optional<std::reference_wrapper<int const> > binary_search_opt9_branch_removal<8, true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0xac>
         :            }
         :            return elements_eytzinger[k];
    1.30 :   406ee2: mov    %rdx,-0x10(%rsp)
    0.00 :   406ee7: mov    $0x1,%eax
    0.00 :   406eec: mov    %al,-0x8(%rsp)
    0.00 :   406ef0: mov    -0x10(%rsp),%rax
    0.25 :   406ef5: mov    -0x8(%rsp),%rdx
    5.98 :   406efa: leaveq
    0.00 :   406efb: retq
    0.00 :   406efc: nopl   0x0(%rax)
         :            for(int32_t i = 0; i < iters; i++) {
    0.00 :   406f00: mov    $0x2,%edx
    0.00 :   406f05: mov    $0x1,%ecx
    0.00 :   406f0a: jmp    406ead <std::optional<std::reference_wrapper<int const> > binary_search_opt9_branch_removal<8, true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x6d>
 Percent |	Source code & Disassembly of binary_search for cycles:u (3258 samples, percent: local period)
-------------------------------------------------------------------------------------------------------------
         :
         :
         :
         :            Disassembly of section .text:
         :
         :            0000000000406c20 <std::optional<std::reference_wrapper<int const> > binary_search_opt4_prefetch<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)>:
         :            _Z27binary_search_opt4_prefetchILb1EESt8optionalISt17reference_wrapperIKiEERKNSt11conditionalIXT_ESt6vectorIi16AlignedAllocatorIiEES6_IiSaIiEEE4typeEi():
         :            return *base;
         :            }
         :
         :            template <bool Aligned>
         :            __attribute__((noinline))
         :            OptRef<const int32_t> binary_search_opt4_prefetch(const VecType<Aligned> & elements, int32_t target) {
    1.11 :   406c20: push   %rbp
    0.00 :   406c21: mov    %esi,%r8d
    0.00 :   406c24: mov    %rsp,%rbp
    0.00 :   406c27: and    $0xffffffffffffffe0,%rsp
         :            data() _GLIBCXX_NOEXCEPT
         :            { return _M_data_ptr(this->_M_impl._M_start); }
         :
         :            const _Tp*
         :            data() const _GLIBCXX_NOEXCEPT
         :            { return _M_data_ptr(this->_M_impl._M_start); }
    0.00 :   406c2b: mov    (%rdi),%rdx
         :            { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
    0.00 :   406c2e: mov    0x8(%rdi),%rax
    0.00 :   406c32: sub    %rdx,%rax
    0.34 :   406c35: sar    $0x2,%rax
         :            const int32_t * base = elements.data();
         :            int32_t len = elements.size();
         :            while (len > 1) {
    0.00 :   406c39: cmp    $0x1,%eax
    0.00 :   406c3c: jle    406c79 <std::optional<std::reference_wrapper<int const> > binary_search_opt4_prefetch<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x59>
    0.00 :   406c3e: mov    %eax,%ecx
         :            int32_t half = len / 2;
         :            __builtin_prefetch(&base[len / 2 - 1]);
         :            __builtin_prefetch(&base[half + len / 2 - 1]);
         :            base += (*(base + half - 1) < target) * half;
    0.00 :   406c40: xor    %r9d,%r9d
    0.00 :   406c43: nopl   0x0(%rax,%rax,1)
         :            int32_t half = len / 2;
    0.77 :   406c48: mov    %ecx,%eax
    0.49 :   406c4a: sar    %eax
         :            __builtin_prefetch(&base[len / 2 - 1]);
    0.61 :   406c4c: movslq %eax,%rsi
    5.74 :   406c4f: lea    -0x4(%rdx,%rsi,4),%rdi
         :            __builtin_prefetch(&base[half + len / 2 - 1]);
    0.61 :   406c54: lea    (%rax,%rax,1),%esi
    0.71 :   406c57: movslq %esi,%rsi
         :            base += (*(base + half - 1) < target) * half;
    0.58 :   406c5a: cmp    %r8d,(%rdi)
         :            __builtin_prefetch(&base[len / 2 - 1]);
   59.76 :   406c5d: prefetcht0 (%rdi)
         :            __builtin_prefetch(&base[half + len / 2 - 1]);
    0.52 :   406c60: prefetcht0 -0x4(%rdx,%rsi,4)
         :            base += (*(base + half - 1) < target) * half;
    0.49 :   406c65: mov    %r9d,%esi
    0.28 :   406c68: cmovl  %eax,%esi
         :            len -= half;
    6.14 :   406c6b: sub    %eax,%ecx
         :            base += (*(base + half - 1) < target) * half;
    0.77 :   406c6d: movslq %esi,%rsi
    6.19 :   406c70: lea    (%rdx,%rsi,4),%rdx
         :            while (len > 1) {
    5.62 :   406c74: cmp    $0x1,%ecx
    0.00 :   406c77: jg     406c48 <std::optional<std::reference_wrapper<int const> > binary_search_opt4_prefetch<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x28>
         :            }
         :            if (*base != target) {
         :            return std::nullopt;
    0.00 :   406c79: xor    %eax,%eax
         :            if (*base != target) {
    0.00 :   406c7b: cmp    %r8d,(%rdx)
    0.00 :   406c7e: jne    406c8a <std::optional<std::reference_wrapper<int const> > binary_search_opt4_prefetch<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x6a>
         :            }
         :            return *base;
    2.73 :   406c80: mov    %rdx,-0x10(%rsp)
    0.00 :   406c85: mov    $0x1,%eax
    0.00 :   406c8a: mov    %al,-0x8(%rsp)
         :            }
    0.00 :   406c8e: mov    -0x10(%rsp),%rax
    0.31 :   406c93: mov    -0x8(%rsp),%rdx
    6.22 :   406c98: leaveq
    0.00 :   406c99: retq
 Percent |	Source code & Disassembly of binary_search for cycles:u (2905 samples, percent: local period)
 ------------------------------------------------------------------------------------------------------------
         :
         :
         :
         :            Disassembly of section .text:
         :
         :            00000000004068c0 <std::optional<std::reference_wrapper<int const> > binary_search_opt5_eytzinger<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)>:
         :            _Z28binary_search_opt5_eytzingerILb1EESt8optionalISt17reference_wrapperIKiEERKNSt11conditionalIXT_ESt6vectorIi16AlignedAllocatorIiEES6_IiSaIiEEE4typeEi():
         :            /**
         :            * @param elements_eytzinger Assume this array is 1-indexed.
         :            */
         :            template <bool Aligned>
         :            __attribute__((noinline))
         :            OptRef<const int32_t> binary_search_opt5_eytzinger(const VecType<Aligned> & elements_eytzinger, int32_t target) {
    3.12 :   4068c0: push   %rbp
    0.00 :   4068c1: mov    %rdi,%rax
    0.00 :   4068c4: mov    %rsp,%rbp
    0.00 :   4068c7: and    $0xffffffffffffffe0,%rsp
         :
         :            // [23.2.4.2] capacity
         :            /**  Returns the number of elements in the %vector.  */
         :            size_type
         :            size() const _GLIBCXX_NOEXCEPT
         :            { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
    0.00 :   4068cb: mov    (%rdi),%rdi
    0.00 :   4068ce: mov    0x8(%rax),%rcx
    0.00 :   4068d2: sub    %rdi,%rcx
    1.73 :   4068d5: mov    %rcx,%r8
    0.00 :   4068d8: sar    $0x2,%r8
         :            int32_t k = 1;
         :            while(k < elements_eytzinger.size()) {
    0.00 :   4068dc: cmp    $0x4,%rcx
    0.00 :   4068e0: jbe    406928 <std::optional<std::reference_wrapper<int const> > binary_search_opt5_eytzinger<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x68>
    0.00 :   4068e2: mov    $0x1,%edx
    0.00 :   4068e7: mov    $0x1,%eax
    0.00 :   4068ec: jmp    406901 <std::optional<std::reference_wrapper<int const> > binary_search_opt5_eytzinger<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x41>
    0.00 :   4068ee: xchg   %ax,%ax
         :            if(elements_eytzinger[k] == target) {
         :            return elements_eytzinger[k];
         :            }
         :            if(elements_eytzinger[k] < target) {
         :            k = 2 * k + 1;
    5.20 :   4068f0: setl   %al
    5.31 :   4068f3: movzbl %al,%eax
    4.51 :   4068f6: lea    (%rax,%rdx,2),%edx
         :            while(k < elements_eytzinger.size()) {
    3.35 :   4068f9: movslq %edx,%rax
    2.42 :   4068fc: cmp    %r8,%rax
    0.00 :   4068ff: jae    406928 <std::optional<std::reference_wrapper<int const> > binary_search_opt5_eytzinger<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x68>
         :            */
         :            const_reference
         :            operator[](size_type __n) const _GLIBCXX_NOEXCEPT
         :            {
         :            __glibcxx_requires_subscript(__n);
         :            return *(this->_M_impl._M_start + __n);
    3.81 :   406901: lea    (%rdi,%rax,4),%rcx
         :            if(elements_eytzinger[k] == target) {
    0.00 :   406905: mov    (%rcx),%eax
   28.29 :   406907: cmp    %esi,%eax
    0.00 :   406909: jne    4068f0 <std::optional<std::reference_wrapper<int const> > binary_search_opt5_eytzinger<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x30>
         :            return elements_eytzinger[k];
    6.12 :   40690b: mov    %rcx,-0x10(%rsp)
         :            } else {
         :            k = 2 * k;
         :            }
         :            }
         :            return std::nullopt;
         :            }
    8.31 :   406910: mov    -0x10(%rsp),%rax
         :            return elements_eytzinger[k];
    2.31 :   406915: movb   $0x1,-0x8(%rsp)
         :            }
    0.35 :   40691a: mov    -0x8(%rsp),%rdx
   25.18 :   40691f: leaveq
    0.00 :   406920: retq
    0.00 :   406921: nopl   0x0(%rax)
         :            return std::nullopt;
    0.00 :   406928: movb   $0x0,-0x8(%rsp)
         :            }
    0.00 :   40692d: mov    -0x10(%rsp),%rax
    0.00 :   406932: mov    -0x8(%rsp),%rdx
    0.00 :   406937: leaveq
    0.00 :   406938: retq
 Percent |	Source code & Disassembly of binary_search for cycles:u (801 samples, percent: local period)
------------------------------------------------------------------------------------------------------------
         :
         :
         :
         :            Disassembly of section .text:
         :
         :            0000000000406850 <std::optional<std::reference_wrapper<int const> > binary_search_opt3_branchless3<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)>:
         :            _Z30binary_search_opt3_branchless3ILb1EESt8optionalISt17reference_wrapperIKiEERKNSt11conditionalIXT_ESt6vectorIi16AlignedAllocatorIiEES6_IiSaIiEEE4typeEi():
         :            return *base;
         :            }
         :
         :            template <bool Aligned>
         :            __attribute__((noinline))
         :            OptRef<const int32_t> binary_search_opt3_branchless3(const VecType<Aligned> & elements, int32_t target) {
    1.75 :   406850: push   %rbp
    0.00 :   406851: mov    %rdi,%rax
    0.00 :   406854: mov    %esi,%edi
    0.00 :   406856: mov    %rsp,%rbp
    0.00 :   406859: and    $0xffffffffffffffe0,%rsp
         :            data() _GLIBCXX_NOEXCEPT
         :            { return _M_data_ptr(this->_M_impl._M_start); }
         :
         :            const _Tp*
         :            data() const _GLIBCXX_NOEXCEPT
         :            { return _M_data_ptr(this->_M_impl._M_start); }
    0.00 :   40685d: mov    (%rax),%rsi
         :            { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
    0.00 :   406860: mov    0x8(%rax),%rdx
    1.87 :   406864: sub    %rsi,%rdx
    0.00 :   406867: sar    $0x2,%rdx
         :            const int32_t * base = elements.data();
         :            int32_t len = elements.size();
         :            while (len > 1) {
    0.00 :   40686b: cmp    $0x1,%edx
    0.00 :   40686e: jle    406897 <std::optional<std::reference_wrapper<int const> > binary_search_opt3_branchless3<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x47>
    0.00 :   406870: mov    %edx,%eax
         :            int32_t half = len / 2;
         :            base += (*(base + half - 1) < target) * half;
    0.00 :   406872: xor    %r8d,%r8d
    0.00 :   406875: nopl   (%rax)
         :            int32_t half = len / 2;
    2.00 :   406878: mov    %eax,%edx
    3.75 :   40687a: sar    %edx
         :            base += (*(base + half - 1) < target) * half;
    3.99 :   40687c: movslq %edx,%rcx
    4.87 :   40687f: cmp    %edi,-0x4(%rsi,%rcx,4)
   20.60 :   406883: mov    %r8d,%ecx
    1.00 :   406886: cmovl  %edx,%ecx
         :            len -= half;
    7.12 :   406889: sub    %edx,%eax
         :            base += (*(base + half - 1) < target) * half;
    1.50 :   40688b: movslq %ecx,%rcx
    5.24 :   40688e: lea    (%rsi,%rcx,4),%rsi
         :            while (len > 1) {
    8.61 :   406892: cmp    $0x1,%eax
    0.00 :   406895: jg     406878 <std::optional<std::reference_wrapper<int const> > binary_search_opt3_branchless3<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x28>
         :            }
         :            if (*base != target) {
         :            return std::nullopt;
    0.00 :   406897: xor    %eax,%eax
         :            if (*base != target) {
    0.00 :   406899: cmp    %edi,(%rsi)
    0.00 :   40689b: jne    4068a7 <std::optional<std::reference_wrapper<int const> > binary_search_opt3_branchless3<true>(std::conditional<true, std::vector<int, AlignedAllocator<int> >, std::vector<int, std::allocator<int> > >::type const&, int)+0x57>
         :            }
         :            return *base;
   11.11 :   40689d: mov    %rsi,-0x10(%rsp)
    0.00 :   4068a2: mov    $0x1,%eax
    0.00 :   4068a7: mov    %al,-0x8(%rsp)
         :            }
    0.00 :   4068ab: mov    -0x10(%rsp),%rax
    1.62 :   4068b0: mov    -0x8(%rsp),%rdx
   24.97 :   4068b5: leaveq
    0.00 :   4068b6: retq
 Percent |	Source code & Disassembly of binary_search for cycles:u (490 samples, percent: local period)
------------------------------------------------------------------------------------------------------------